[
  {
    "objectID": "ref/codes.html",
    "href": "ref/codes.html",
    "title": "Codes",
    "section": "",
    "text": "Contact Info\n\n[street:...]\n[city:...]\n[prov:...]\n[pc:...]\n[country:...]\n[ph:...]\n[cell:...]\n\n[remove phone]\n\n[rbp]\n\nNote that street, city, etc. is only needed for non-Canadian addresses. Canadian addresses, within certain formatting specifications, will be picked up automatically.\nExamples:\n\nsu.extract_address1(\"123 Sesame St, Toronto, ON  M2Z1J9\")\n\n('123 Sesame St', 'Toronto', 'ON', 'M2Z 1J9', 'Canada')\n\n\n\nsu.extract_address1(\n    \"c/o Bob Roberts, 123 Sesame St, Toronto, ON                              M2Z   1J9\"\n)\n\n('c/o Bob Roberts, 123 Sesame St', 'Toronto', 'ON', 'M2Z 1J9', 'Canada')\n\n\n\nsu.extract_address1(\n    \"c/o Bob Roberts, 123 Sesame St,    Toronto   , on             m2z     1J9\"\n)\n\n('c/o Bob Roberts, 123 Sesame St', 'Toronto', 'ON', 'M2Z 1J9', 'Canada')\n\n\nUse commas to separate street, city, and province. Province should be abbreviated.\n\n# error - missing comma\nsu.extract_address1(\"Green Grove, 123 Sesame St,Toronto    on             m2z     1J9\")\n\n2024-12-31 20:13:21.423 | WARNING  | srs_updates.core:extract_address1:441 - Check province - s/b abbreviated; input str: Green Grove, 123 Sesame St,Toronto    on             m2z     1J9\n\n\nCheck province\n\n\n('Green Grove', '123 Sesame St', 'TO', 'M2Z 1J9', 'Canada')\n\n\n\nsu.extract_address1(\n    \"Green Grove, 123 Sesame St,Toronto,    on,             m2z     1J9\"\n)\n\n('Green Grove, 123 Sesame St', 'Toronto', 'ON', 'M2Z 1J9', 'Canada')\n\n\n\n# error - province not abbreviated\nsu.extract_address1(\n    \"Green Grove, 123 Sesame St,Toronto,    Quebec,             m2z     1J9\"\n)\n\n2024-12-31 20:13:21.456 | WARNING  | srs_updates.core:extract_address1:441 - Check province - s/b abbreviated; input str: Green Grove, 123 Sesame St,Toronto,    Quebec,             m2z     1J9\n\n\nCheck province\n\n\n('Green Grove, 123 Sesame St', 'Toronto', 'QU', 'M2Z 1J9', 'Canada')\n\n\nIf there’s other text in front of the address, use // as a separator:\n\nsu.extract_address1(\n    \"some text here // Green Grove Retirement Community, 123 Sesame St,Toronto,    QC,             m2z     1J9\"\n)\n\n('Green Grove Retirement Community, 123 Sesame St',\n 'Toronto',\n 'QC',\n 'M2Z 1J9',\n 'Canada')\n\n\nEmails will also be picked up automatically.\nPhone numbers, if formatted as xxx-xxx-xxxx will also be picked up. Use the [ph:...] code if the format is different (e.g., number has extension). Use [cell:...] to specify cell phone numbers, otherwise it will be picked up as a main/home phone number.\n\n\nDeaths\n\n[mdod:...] or [md:...] - member date of death\n\n[dc] - member proof of death\n\n[sdod:...] or [sd:...] - spouse date of death\n\n[sdc] - spouse proof of death\n\nValues passed into md/sd should preferably be formatted like 1-jan-2020 but any format parseable by the pandas.to_datetime function will work.\n\npd.to_datetime(\"01-jan-2020\")\n\nTimestamp('2020-01-01 00:00:00')\n\n\n\npd.to_datetime(\"1-jan-2020\")\n\nTimestamp('2020-01-01 00:00:00')\n\n\n\npd.to_datetime(\"Jan 1, 2020\")\n\nTimestamp('2020-01-01 00:00:00')\n\n\n\npd.to_datetime(\"Jan. 1, 2020\")\n\nTimestamp('2020-01-01 00:00:00')\n\n\n\npd.to_datetime(\"January 1, 2020\")\n\nTimestamp('2020-01-01 00:00:00')\n\n\n\npd.to_datetime(\"5/17/2020\")\n\nTimestamp('2020-05-17 00:00:00')\n\n\nIt’s best to avoid ambiguous formats like the one above. If there’s ambiguity, the default assumption is the month comes first:\n\npd.to_datetime(\"7/11/2020\")\n\nTimestamp('2020-07-11 00:00:00')\n\n\n\n\nNames\n\n[fn:...] / [ln:...] - member name\n[sfn:...] / [sln:...] - spouse name\n\n\n\nDOB\n\n[mdob:&lt;date&gt;]\n[sdob:&lt;date&gt;]\n[poa] - - For member proof of age column\n[spoa] - For spouse proof of age column\n\n\n\nBanking\n\n[bank:...]\n\nShould be formatted as [bank:xxx-xxxxx-x...]. Simple validation is included to check length of institution/transit numbers.\n\n\nSuspend\n\n[sus] - suspend payments\n\n\n\nMisc\n\n[cls] - flag to close log if default behaviour is to re-assign\n[excl] - indicates the update should be excluded from the maintenance file\n[comment:...] - append to Comment column in address file\n\n[rbp] - adds Returned Mail flag to internal database, sets mailing address to TELUS Health address in CIBC Mellon’s database",
    "crumbs": [
      "ref",
      "Codes"
    ]
  },
  {
    "objectID": "update_xl.html",
    "href": "update_xl.html",
    "title": "08_update_xl",
    "section": "",
    "text": "Module for updating address file. Full package/docs can be found here.\n\n\n00 update\n\n\nmain\n\n main (key_col:str, str_cols:Optional[list]=None,\n       input_file:str='./Book1.xlsx', _changelog_dir:str='./')\n\n…\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nkey_col\nstr\n\nunique id column\n\n\nstr_cols\nOptional\nNone\nAdd all cols where there may be leading zeroes that should be preserved, or if the values should be read in as string.\n\n\ninput_file\nstr\n./Book1.xlsx\nname/path to input file\n\n\n_changelog_dir\nstr\n./\nset path for changelog yml output\n\n\nReturns\nNone",
    "crumbs": [
      "08_update_xl"
    ]
  },
  {
    "objectID": "srs_specific.html",
    "href": "srs_specific.html",
    "title": "03_srs_specific",
    "section": "",
    "text": "Class to store and further process UpdateData objects\n\n\n\n\n\n Updates (notes_list:list[str],\n          all_updates:list[srs_updates.update_data.UpdateData]=&lt;factory&gt;,\n          date:str='2025-04-25', rel_pin_ids:list[str]=&lt;factory&gt;,\n          query_df:pandas.core.frame.DataFrame|None=None,\n          test_cml_fp:str|None=None)\n\n\n\n\nnotes_list: list[str]\nall_updates: list[ud.UpdateData] = field(default_factory=_default_empty_list)\ndate: str = _init_ts()\nrel_pin_ids: list[str] = field(default_factory=_default_empty_list)\nquery_df: pd.DataFrame = None\n\n\n\n\n\n\n\n Updates.processNotesPrelim ()\n\n*Preliminary processing and conversion of notes into UpdateData objects:\n\nconvert notes into UpdateData objects\nadd first name + suffix if there was a death\ncreate note for re-assigning death-related Harmony logs\nassigns list of UpdateData objects to self.all_updates*\n\n\n\n\n\n\n Updates.filterPinIDs ()\n\nFilter PIN IDs to speed up addAssociatedIDs method. Assigns filtered list to self.rel_pin_ids\n\n\n\n\n\n Updates.addAssociatedIDs ()\n\nFor each UpdateData object, add all associated PIN IDs to ud.rel_pin_ids. E.g., S1234567, X1234567, T1234567, 1234567 would all be associated with a base ID of 1234567.\n\n\n\n\n\n Updates.determineIfSrv ()\n\nCheck if SS in pay\n\n\n\n\n\n Updates.loadQueryDF ()\n\nLoads query tab from CML tracker and assigns to self.query_df\n\n\n\n\n\n Updates.addKeyAndTktNum ()\n\nFor each UpdateData object, check self.query_df for key and ticket number and assign to ud.key and ud.ticket_num\n\n\n\n\n\n Updates.getPinGroup ()\n\nGet payee/PIN group from curr_mbrs sheet for all associated PIN IDs. Append results to ud.pin_group field.\n\n\n\n\n\n Updates.cleanCurrStatus ()\n\nClean current status / date of current status based on UpdateData srv field. Clear Current Status and Date of Current Status if only pre-deceased spouse death reported.\n\n\n\n\n\n Updates.fixPayeeStatus ()\n\nRemove payee status if it’s a spouse death but not SS in PIN.\n\n\n\n\n\n Updates.pinUpdateCheck ()\n\nDetermine which updates s/b included in/excluded from maintenance file\n\n\n\n\n\n\n\n\n Updates.getAFUpdatesDF ()\n\n-&gt; pd.DataFrame - create df for updating address file",
    "crumbs": [
      "03_srs_specific"
    ]
  },
  {
    "objectID": "srs_specific.html#fields",
    "href": "srs_specific.html#fields",
    "title": "03_srs_specific",
    "section": "",
    "text": "notes_list: list[str]\nall_updates: list[ud.UpdateData] = field(default_factory=_default_empty_list)\ndate: str = _init_ts()\nrel_pin_ids: list[str] = field(default_factory=_default_empty_list)\nquery_df: pd.DataFrame = None",
    "crumbs": [
      "03_srs_specific"
    ]
  },
  {
    "objectID": "srs_specific.html#methods-post-init",
    "href": "srs_specific.html#methods-post-init",
    "title": "03_srs_specific",
    "section": "",
    "text": "Updates.processNotesPrelim ()\n\n*Preliminary processing and conversion of notes into UpdateData objects:\n\nconvert notes into UpdateData objects\nadd first name + suffix if there was a death\ncreate note for re-assigning death-related Harmony logs\nassigns list of UpdateData objects to self.all_updates*\n\n\n\n\n\n\n Updates.filterPinIDs ()\n\nFilter PIN IDs to speed up addAssociatedIDs method. Assigns filtered list to self.rel_pin_ids\n\n\n\n\n\n Updates.addAssociatedIDs ()\n\nFor each UpdateData object, add all associated PIN IDs to ud.rel_pin_ids. E.g., S1234567, X1234567, T1234567, 1234567 would all be associated with a base ID of 1234567.\n\n\n\n\n\n Updates.determineIfSrv ()\n\nCheck if SS in pay\n\n\n\n\n\n Updates.loadQueryDF ()\n\nLoads query tab from CML tracker and assigns to self.query_df\n\n\n\n\n\n Updates.addKeyAndTktNum ()\n\nFor each UpdateData object, check self.query_df for key and ticket number and assign to ud.key and ud.ticket_num\n\n\n\n\n\n Updates.getPinGroup ()\n\nGet payee/PIN group from curr_mbrs sheet for all associated PIN IDs. Append results to ud.pin_group field.\n\n\n\n\n\n Updates.cleanCurrStatus ()\n\nClean current status / date of current status based on UpdateData srv field. Clear Current Status and Date of Current Status if only pre-deceased spouse death reported.\n\n\n\n\n\n Updates.fixPayeeStatus ()\n\nRemove payee status if it’s a spouse death but not SS in PIN.\n\n\n\n\n\n Updates.pinUpdateCheck ()\n\nDetermine which updates s/b included in/excluded from maintenance file",
    "crumbs": [
      "03_srs_specific"
    ]
  },
  {
    "objectID": "srs_specific.html#methods-public",
    "href": "srs_specific.html#methods-public",
    "title": "03_srs_specific",
    "section": "",
    "text": "Updates.getAFUpdatesDF ()\n\n-&gt; pd.DataFrame - create df for updating address file",
    "crumbs": [
      "03_srs_specific"
    ]
  },
  {
    "objectID": "core.html",
    "href": "core.html",
    "title": "00_core",
    "section": "",
    "text": "00 init\n\n\nsetupLogger\n\n setupLogger (name:str='log', serialize:bool=False)\n\nadd handler attached to &lt;name&gt;.log @ trace level and up\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nname\nstr\nlog\nstr\n\n\nserialize\nbool\nFalse\nbool\n\n\nReturns\nNone\n\n\n\n\n\n\n\n\nloadSerializedLog\n\n loadSerializedLog (log_fp:str, incl_full_record:bool=False,\n                    incl_unix_ts:bool=False)\n\n-&gt; pd.DataFrame\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nlog_fp\nstr\n\nstr\n\n\nincl_full_record\nbool\nFalse\nbool\n\n\nincl_unix_ts\nbool\nFalse\nbool\n\n\nReturns\nDataFrame\n\npd.DataFrame\n\n\n\n\n\n\nyaml_helper\n\n yaml_helper (fpath:str='./config.yaml', mode:str='r',\n              data:Optional[dict]=None)\n\nHelper function to read, write, append to files in yaml format. Checks for duplicate keys if reading or appending.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nfpath\nstr\n./config.yaml\nstr\n\n\nmode\nstr\nr\nstr - r / a / w\n\n\ndata\nOptional\nNone\ncannot be None if writing or appending\n\n\nReturns\ndict\n\ndict - data if reading, {‘r’: 0} if writing/appending\n\n\n\n\n\nTests\n_fp = fp(\"../cfg/cfg.yml\")\nassert os.path.exists(_fp)\nassert list(yaml_helper(_fp).keys()) == [\"test_cml_fp\"]\n\n\n\n\n\n01 extract emails\n\n\nextract_emails\n\n extract_emails (t_str:str)\n\nExtract all emails from note. If multiple emails found, join w/ //…\n\n\n\n\nType\nDetails\n\n\n\n\nt_str\nstr\nstr\n\n\nReturns\nstr\nemail address\n\n\n\n\n\nTests\nassert extract_emails(\"Some text here bob@gmail.ca some text here\") == \"bob@gmail.ca\"\nassert (\n    extract_emails(\"sdasd asd a232 very.common@example.com //\")\n    == \"very.common@example.com\"\n)\n\nt_str = \"sdasd asd FirstName.LastName@EasierReading.org\"\nassert extract_emails(t_str) == \"FirstName.LastName@EasierReading.org\"\nassert extract_emails(\"sds extract_emails x@example.com asda \") == \"x@example.com\"\nassert (\n    extract_emails(\n        \"long.email-address-with-hyphens@and.subdomains.example.com asda dasd asdasd \"\n    )\n    == \"long.email-address-with-hyphens@and.subdomains.example.com\"\n)\n\nt_str = \"dasd adasd user.name+tag+sorting@example.com asd asd \"\nassert extract_emails(t_str) == \"user.name+tag+sorting@example.com\"\n\nt_str = \"dasd adasd user.name+tag+sorting@s.example    asd asd \"\nassert extract_emails(t_str) == \"user.name+tag+sorting@s.example\"\n\nt_str = (\n    \"dasd bob@gmail.com adasd user.name+tag+sorting@s.example    asd asd \"\n    + \"dasd adasd user.name+tag+sorting@example.com asd asd \"\n)\nassert (\n    extract_emails(t_str)\n    == \"bob@gmail.com // user.name+tag+sorting@s.example // user.name+tag+sorting@example.com\"\n)\n\n\nSupposedly, this is a valid email but the script won’t pick it up. Unlikely to encounter.\n\nt_str = \"admin@exampl sdasd \"\nextract_emails(t_str)\n\n''\n\n\nForward slash is supposedly valid as well but the script won’t pick this up. Unlikely to encounter.\n\nt_str = \"dasd name/surname@example.com sdasd \"\nextract_emails(t_str)\n\n'surname@example.com'\n\n\n\n\n\n02 extract phone numbers\n\n\nextract_phone1\n\n extract_phone1 (t_str:str)\n\n*Extract all phone numbers using xxx-xxx-xxxx pattern or [ph:...] if alternate format (eg. [ph:123-456-7890 ext. 8001]).\nIf the latter pattern is found, does not check for the former.*\n\n\n\n\nType\nDetails\n\n\n\n\nt_str\nstr\nstr\n\n\nReturns\nstr\nstr\n\n\n\n\n\nTests\nassert (\n    extract_phone1(\"dasda  123-123-1234 // 123-343-4521 \")\n    == \"123-123-1234 // 123-343-4521\"\n)\nassert (\n    extract_phone1(\"asdasd as [ph: 903-123-4365 ext 8001] // sadasd \")\n    == \"903-123-4365 ext 8001\"\n)\nassert (\n    extract_phone1(\"asdasd as [pH: 903-123-4365 ext 8001] // sadasd \")\n    == \"903-123-4365 ext 8001\"\n)\n\n\nUse [ph:...] for phone numbers that have a pattern different from xxx-xxx-xxxx.\nIf using [ph:...] and there are multiple numbers, put them all within the square brackets.\n\n\nTests\nassert (\n    extract_phone1(\n        \"asdasd as [pH: 903-123-4365 ext 8001] // 123-456-7890 - [cell:999-999-9999] sadasd \"\n    )\n    == \"903-123-4365 ext 8001\"\n)\nassert (\n    extract_phone1(\n        \"asdasd as [pH: 903-123-4365 ext 8001 // 123-456-7890] //  [cell:999-999-9999] sadasd \"\n    )\n    == \"903-123-4365 ext 8001 // 123-456-7890\"\n)\n\n\n\n\n\nextract_phone2\n\n extract_phone2 (t_str:str)\n\nWork or cell - put inside [cell:...]\n\n\n\n\nType\nDetails\n\n\n\n\nt_str\nstr\nstr\n\n\nReturns\nstr\nstr\n\n\n\n\n\nTests\nassert extract_phone2(\"asdsad 123-213-4521\") == \"\"\nassert extract_phone2(\"asdsad [cell: 123-213-4521  ]\") == \"123-213-4521\"\nassert extract_phone2(\"asdsad [CELL:  123-213-4521  ]\") == \"123-213-4521\"\nassert (\n    extract_phone2(\"asdsad [CELL:  123-213-4521 // 999-99999999999 ]\")\n    == \"123-213-4521 // 999-99999999999\"\n)\n\n\n\n\n\nextract_phone_numbers\n\n extract_phone_numbers (t_str:str)\n\nMain function to extract phone numbers from a note using regex pattern and/or [ph:...] / [cell:...] flags. To remove all phone numbers on file, use [remove phone].\n\n\n\n\nType\nDetails\n\n\n\n\nt_str\nstr\nstr\n\n\nReturns\ntuple\ntuple[str, str]\n\n\n\n\nextract_phone_numbers(\".. [remove phone] asdsad\")\n\n('&lt;&lt;&lt;blank&gt;&gt;&gt;', '&lt;&lt;&lt;blank&gt;&gt;&gt;')\n\n\n&lt;&lt;&lt;blank&gt;&gt;&gt; tells the update_xl module to clear existing data.\n\nextract_phone_numbers(\"123 sesame st ... 123-345-3245 // [cell: 9051235453]\")\n\n('123-345-3245', '9051235453')\n\n\nMore tests:\n\n\nTests\nassert extract_phone_numbers(\n    \"123 sesame st ... 123-345-3245 // [cell: 905-123-5453]\"\n) == (\"123-345-3245\", \"905-123-5453\")\nassert extract_phone_numbers(\n    \"... [ph: 123-432-5643 ext 900] // [cell: 123-345-4452 ext 9000 ]\"\n) == (\"123-432-5643 ext 900\", \"123-345-4452 ext 9000\")\n\nassert extract_phone_numbers(\"234 123-123-1234 // 234-234-2345\") == (\n    \"123-123-1234 // 234-234-2345\",\n    \"\",\n)\nassert extract_phone_numbers(\n    \"223423434 sadasd 123-123-1234 // 234-234-2345 // [cell: 123-543-9999]\"\n) == (\"123-123-1234 // 234-234-2345\", \"123-543-9999\")\n\nassert extract_phone_numbers(\n    \"223423434 sadasd [ph: 123-123-1234 // 234-234-2345 (POA)] 456-234-1231 // [cell: 123-543-9999]\"\n) == (\"123-123-1234 // 234-234-2345 (POA)\", \"123-543-9999\")\n\nt_str = \"[cell:306-535-5490]\"\nassert extract_phone_numbers(t_str) == (\"\", \"306-535-5490\")\n\nt_str = \"... 306-535-5490 sdasd\"\nassert extract_phone_numbers(t_str) == (\"306-535-5490\", \"\")\n\n\n\n\n\n03 extract address\n\n\nfull_prov_name\n\n full_prov_name (t_str:str)\n\nAddress file uses full name, not abbreviation\n\n\n\n\nType\nDetails\n\n\n\n\nt_str\nstr\nstr\n\n\nReturns\nstr\nstr\n\n\n\n\n\nTests\nassert full_prov_name(\"FL\") == \"FL\"  # if not found, returns input string\nassert full_prov_name(\"on\") == \"Ontario\"\nassert full_prov_name(\"yt\") == \"Yukon\"\nassert full_prov_name(\"Bc\") == \"British Columbia\"\n\n\n\n\n\nextract_address1\n\n extract_address1 (t_str:str)\n\nFor Canadian addresses.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nt_str\nstr\nstr\n\n\nReturns\ntuple\ntuple[str, str, str, str, str]: (street, city, abbreviated province, postal code, country)\n\n\n\nAddress can be formatted in a variety of ways. See below tests for examples.\n\n\nTests\nt_str = \"... // c/o Jim Bob, 123 Sesame St, Toronto, ON  M5X 2D1  // ... \"\nassert extract_address1(t_str) == (\n    \"c/o Jim Bob, 123 Sesame St\",\n    \"Toronto\",\n    \"ON\",\n    \"M5X 2D1\",\n    \"Canada\",\n)\nt_str = \"... // c/o Jim Bob, 123 Sesame St, Toronto, ON   M5X2D1  // ... \"\nassert extract_address1(t_str) == (\n    \"c/o Jim Bob, 123 Sesame St\",\n    \"Toronto\",\n    \"ON\",\n    \"M5X 2D1\",\n    \"Canada\",\n)\nt_str = \"... // c/o Jim Bob, 123 Sesame St, Toronto, ON.   M5X2D1  // ... \"\nassert extract_address1(t_str) == (\n    \"c/o Jim Bob, 123 Sesame St\",\n    \"Toronto\",\n    \"ON\",\n    \"M5X 2D1\",\n    \"Canada\",\n)\nt_str = \"... // c/o Jim Bob, 123 Sesame St, Quebec,  QC.   M5X2D1  // ... \"\nassert extract_address1(t_str) == (\n    \"c/o Jim Bob, 123 Sesame St\",\n    \"Quebec\",\n    \"QC\",\n    \"M5X 2D1\",\n    \"Canada\",\n)\nt_str = \"... // c/o Jim Bob, 123 Sesame St, Quebec,  qc.   M5X2D1  // ... \"\nassert extract_address1(t_str) == (\n    \"c/o Jim Bob, 123 Sesame St\",\n    \"Quebec\",\n    \"QC\",\n    \"M5X 2D1\",\n    \"Canada\",\n)\nt_str = \"... // c/o Jim Bob, 123 Sesame St, Some City,  pe,   M5X2D1  // ... \"\nassert extract_address1(t_str) == (\n    \"c/o Jim Bob, 123 Sesame St\",\n    \"Some City\",\n    \"PE\",\n    \"M5X 2D1\",\n    \"Canada\",\n)\n\n\nIf the pattern indicates it is a Canadian address but the province isn’t a valid abbreviation, a warning will be raised:\n\nt_str = \"... // c/o Jim Bob, 123 Sesame St, Some City,  Manitoba,   M5X2D1  // ... \"\nextract_address1(t_str)\n\n2025-04-25 12:49:47.273 | WARNING  | __main__:extract_address1:49 - Check province - s/b abbreviated; input str: ... // c/o Jim Bob, 123 Sesame St, Some City,  Manitoba,   M5X2D1  // ... \n\n\n('c/o Jim Bob, 123 Sesame St', 'Some City', 'MA', 'M5X 2D1', 'Canada')\n\n\n\n\n\nextract_address2\n\n extract_address2 (t_str:str)\n\nextract_address1 only works for Canadian addresses. This one is for non-Canadian addresses.\n\n\n\n\nType\nDetails\n\n\n\n\nt_str\nstr\nstr\n\n\nReturns\ntuple\ntuple[str, str, str, str, str]\n\n\n\n\n\nTests\nt_str = \"[street:123 Sesame St][city:Miami][prov:FL][pc:02345][country:US]\"\nassert extract_address2(t_str) == (\"123 Sesame St\", \"Miami\", \"FL\", \"02345\", \"US\")\n\n\n\n\n\n04 name updates\n\n\nextract_names\n\n extract_names (t_str:str)\n\n[fn:...] / [ln:...] for member. [sfn:...] / [sln:...] for spouse.\n\n\n\n\nType\nDetails\n\n\n\n\nt_str\nstr\nstr\n\n\nReturns\ntuple\ntuple[str, str, str, str]\n\n\n\n\n\nTests\nt_str = \"[FN:Bob][Ln: Jim] [sfn:Mary][sln:Thomas]\"\nassert extract_names(t_str) == (\"Bob\", \"Jim\", \"Mary\", \"Thomas\")\n\nt_str = \"[FN:Bob][sfn:Mary][sln:Thomas]\"\nassert extract_names(t_str) == (\"Bob\", \"\", \"Mary\", \"Thomas\")\n\nt_str = \"[fn:  Sam ]\"\nassert extract_names(t_str) == (\"Sam\", \"\", \"\", \"\")\n\n\n\n\n\n05 deaths\n\n\ncheck_mbr_death\n\n check_mbr_death (t_str:str)\n\nChecks for either [mdod:&lt;dod&gt;] or [md:&lt;dod&gt;] in note. &lt;dod&gt; should be a string that can be parsed by the pandas.to_datetime function. Preferably in the format of 1-jan-2020, for example. If there’s proof of death, add [dc] to note.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nt_str\nstr\nstr\n\n\nReturns\ntuple\ntuple[str, str] - (dod formatted as str, proof of death)\n\n\n\n\n\nTests\nassert check_mbr_death(\" // [mdod:1-jan-2020][dc] // \") == (\n    (\"2020-01-01\"),\n    \"Yes\",\n)\nassert check_mbr_death(\" // [md:1-jan-2020][DC] // \") == (\n    (\"2020-01-01\"),\n    \"Yes\",\n)\nassert check_mbr_death(\" // [md:1-feb-2023] // \") == (\n    (\"2023-02-01\"),\n    \"\",\n)\nassert check_mbr_death(\" // [mdob:1-feb-2023] // \") == (\n    \"\",\n    \"\",\n)\nassert check_mbr_death(\" // [dc] // \") == (\n    \"\",\n    \"Yes\",\n)\n\n\n\n\n\ncheck_spouse_death\n\n check_spouse_death (t_str:str)\n\nChecks for either [sdod:&lt;dod&gt;] or [sd:&lt;dod&gt;] in note. &lt;dod&gt; should be a string that can be parsed by the pandas.to_datetime function. Preferably in the format of 1-jan-2020, for example. If there’s proof of death, add [sdc] to note.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nt_str\nstr\nstr\n\n\nReturns\ntuple\ntuple[str,str] - (dod formatted as str, proof of death)\n\n\n\n\n\nTests\nassert check_spouse_death(\" // [sdod:1-jan-2020][sdc] // \") == (\n    (\"2020-01-01\"),\n    \"Yes\",\n)\nassert check_spouse_death(\" // [sd:1-jan-2020][sdc] // \") == (\n    (\"2020-01-01\"),\n    \"Yes\",\n)\nassert check_spouse_death(\" // [sd:1-feb-2023] // \") == (\n    (\"2023-02-01\"),\n    \"\",\n)\nassert check_spouse_death(\" // [sdob:1-feb-2023] // \") == (\n    \"\",\n    \"\",\n)\nassert check_spouse_death(\" // [sdc] // \") == (\n    \"\",\n    \"Yes\",\n)\n\n\n\n\n\nget_cs\n\n get_cs (t_str:str)\n\nGet preliminary current status and date of current status.\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nt_str\nstr\nstr\n\n\nReturns\ntuple\n(current status, curr status date formatted as str)\n\n\n\n\n\nTests\nt_str = \"[sd:1-jan-2023][md:1-feb-2024]\"\nassert get_cs(t_str) == (\"N/A (died)\", (\"2024-02-01\"))\n\nt_str = \"[sd:1-jan-2023][md:1-feb-2024]\"\nassert get_cs(t_str) == (\"N/A (died)\", (\"2024-02-01\"))\n\nt_str = \"[md:1-feb-2024]\"\nassert get_cs(t_str) == (\"N/A (died)\", (\"2024-02-01\"))\n\nt_str = \"[sd:1-feb-2024]\"\nassert get_cs(t_str) == (\"N/A (died)\", (\"2024-02-01\"))\n\n\n\n\n\n06 payee status, banking\n\nDeath of payee == payee status of 04\nIf both death notification and banking received:\n\nMember death notification + banking\n\nno need to add banking to maintenance file\n\nSpouse death notification + banking\n\nPre-deceased spouse: add banking to maintenance file\nSurvivor death: no need to add banking to maintenance file\n\n\n\n\n\npayee_status_and_banking\n\n payee_status_and_banking (t_str:str, validate:bool=True)\n\nGet payee status for PIN: 00 for banking update, 01 for suspend, 04 for payee death. If 00, 2nd element will be new banking info.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nt_str\nstr\n\nstr\n\n\nvalidate\nbool\nTrue\ncheck length of inst / transit numbers\n\n\nReturns\ntuple\n\ntuple[str, str]: (new status code, new banking) // (\"\", \"\") if no change\n\n\n\n\n\nTests\nassert payee_status_and_banking(\"// [bank:123-12334-312312312312] asdasd \") == (\n    \"00\",\n    \"123-12334-312312312312\",\n)\nassert payee_status_and_banking(\"[sus]\") == (\"01\", \"\")\n\nwith pytest.raises(\n    Exception, match=\"Can't suspend payments and update banking info at the same time\"\n):\n    payee_status_and_banking(\"[sus][bank:...]\")\n\nwith pytest.raises(AssertionError, match=\"Invalid transit\"):\n    payee_status_and_banking(\"// [bank:123-132334-312312312312] asdasd \")\nwith pytest.raises(AssertionError, match=\"Invalid institution\"):\n    payee_status_and_banking(\"// [bank:23-13234-312312312312] asdasd \")\n\nassert payee_status_and_banking(\n    \"// [sdod:1-jan-2024][bank:123-12334-312312312312]\"\n) == (\"04\", \"\")\n\nassert payee_status_and_banking(\n    \"// [mdod:1-jan-2024][bank:123-12334-312312312312]\"\n) == (\"04\", \"\")\n\nassert payee_status_and_banking(\"[mdod:1-jan-2020]\") == (\"04\", \"\")\nassert payee_status_and_banking(\"[sdod:1-jan-2020]\") == (\"04\", \"\")\n\nassert payee_status_and_banking(\n    \"// [sdod:1-jan-2020][bank:123-12334-312312312312]\"\n) == (\"04\", \"\")\nassert payee_status_and_banking(\n    \"// [mdod:1-jan-2020][bank:123-12334-312312312312]\"\n) == (\"04\", \"\")\n\n\n\n\n\n07 DOB\n\n\ndob_updates\n\n dob_updates (t_str:str)\n\nUpdate DOB in both address file and PIN using the following patterns: [mdob:&lt;dob&gt;], [sdob:&lt;sdob&gt;]\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nt_str\nstr\nstr\n\n\nReturns\ntuple\n(mdob formatted as str, sdob formatted as str)\n\n\n\n\n\nTests\nt_str = \"[mdob:1-jan-1960]\"\nassert dob_updates(t_str) == (\"1960-01-01\", \"\")\nt_str = \"[sdob:1-jan-1960]\"\nassert dob_updates(t_str) == (\"\", \"1960-01-01\")\nt_str = \"[mdob:28-feb-1954][sdob:1-jan-1960]\"\nassert dob_updates(t_str) == (\n    \"1954-02-28\",\n    \"1960-01-01\",\n)",
    "crumbs": [
      "00_core"
    ]
  },
  {
    "objectID": "update_data.html",
    "href": "update_data.html",
    "title": "01_update_data",
    "section": "",
    "text": "Data class to store data associated with various updates (address file, maintenance file, etc).\nUsing a data class here allows for greater flexibility when adding more properties later.\nOther modules in this package extracts/modifies properties/fields to generate files for internal and external data updates.",
    "crumbs": [
      "01_update_data"
    ]
  },
  {
    "objectID": "update_data.html#fields",
    "href": "update_data.html#fields",
    "title": "01_update_data",
    "section": "Fields",
    "text": "Fields\nnote: str = \"\"  # full note incl ID and URL\n\n# contact info\nemail: str = \"\"\nphone1: str = \"\"\nphone2: str = \"\"\nstreet: str = \"\"\ncity: str = \"\"\nprov: str = \"\"\npc: str = \"\"\ncountry: str = \"\"\n\n# names\nmfn: str = \"\"\nmln: str = \"\"\nsfn: str = \"\"\nsln: str = \"\"\npin_fn: str = \"\"\npin_ln: str = \"\"\n\n# death\nmdod_str: str = \"\"\nmdc: str = \"\"\nsdod_str: str = \"\"\nsdc: str = \"\"\n\n# for Harmony\ndeath_note: str = \"\"\nticket_num: str = \"\"\nkey: str = \"\"  # from legacy system, before ticket #s were implemented\n\n# current status\ncs: str = \"\"\ncsd_str: str = \"\"\n\n# dob\nmdob_str: str = \"\"\nsdob_str: str = \"\"\n\n# PIN\npayee_status: str = \"\"\nbanking: str = \"\"\nsrv: bool = False\npin_update: bool = False\nrel_pin_ids: list = field(default_factory=_default_empty_list)\npin_group: list = field(default_factory=_default_empty_list)",
    "crumbs": [
      "01_update_data"
    ]
  },
  {
    "objectID": "update_data.html#properties",
    "href": "update_data.html#properties",
    "title": "01_update_data",
    "section": "Properties",
    "text": "Properties\n\n\nUpdateData.ee_id\n\n UpdateData.ee_id ()\n\n-&gt; str - Emp ID #1\n\n\n\nUpdateData.harmony_url\n\n UpdateData.harmony_url ()\n\n-&gt; str - url\n\n\n\nUpdateData.update_date\n\n UpdateData.update_date ()\n\n-&gt; pd.Timestamp | None // Contact info update date\n\n\n\nUpdateData.full_prov\n\n UpdateData.full_prov ()\n\n-&gt; str - full province name for address file\n\n\n\nUpdateData.bank_inst\n\n UpdateData.bank_inst ()\n\n-&gt; str - inst #\n\n\n\nUpdateData.bank_transit\n\n UpdateData.bank_transit ()\n\n-&gt; str - transit #\n\n\n\nUpdateData.bank_acc\n\n UpdateData.bank_acc ()\n\n-&gt; str - account #\n\n\n\nUpdateData.mdod\n\n UpdateData.mdod ()\n\n-&gt; pd.Timestamp | None // member DOD\n\n\n\nUpdateData.sdod\n\n UpdateData.sdod ()\n\n-&gt; pd.Timestamp | None // spouse DoD\n\n\n\nUpdateData.csd\n\n UpdateData.csd ()\n\n-&gt; pd.Timestamp | None // Date of Current Status\n\n\n\nUpdateData.mdob\n\n UpdateData.mdob ()\n\n-&gt; pd.Timestamp | None\n\n\n\nUpdateData.sdob\n\n UpdateData.sdob ()\n\n-&gt; pd.Timestamp | None\n\n\n\nUpdateData.street1\n\n UpdateData.street1 ()\n\n-&gt; str - split if c/o in street or if length exceeds 30 characters\n\n\n\nUpdateData.street2\n\n UpdateData.street2 ()\n\n-&gt; str\n\n\n\nUpdateData.close\n\n UpdateData.close ()\n\n-&gt; str - Flag if the Harmony log should be closed or re-assigned. Y == close, N == re-assign (death case)\n\n\n\nUpdateData.comment\n\n UpdateData.comment ()\n\n-&gt; str | None // For Comment column in address file\n\n\n\nUpdateData.poa\n\n UpdateData.poa ()\n\n-&gt; str | None // Member's Proof of Age on file?\n\n\n\nUpdateData.spoa\n\n UpdateData.spoa ()\n\n-&gt; str | None // Spouse’s Proof of Age on file?\n\n\n\nUpdateData.rbp\n\n UpdateData.rbp ()\n\n-&gt; bool",
    "crumbs": [
      "01_update_data"
    ]
  },
  {
    "objectID": "update_data.html#methods",
    "href": "update_data.html#methods",
    "title": "01_update_data",
    "section": "Methods",
    "text": "Methods\n\n\nUpdateData.addNameSuffixIfDeceased\n\n UpdateData.addNameSuffixIfDeceased ()\n\nAdd (Estate of) suffix to first name for deceased member, (died) for deceased spouse\n\n\n\nUpdateData.setSrvFlag\n\n UpdateData.setSrvFlag ()\n\nChecks all associated PIN IDs for a S prefix. Modifies self.srv field if found.",
    "crumbs": [
      "01_update_data"
    ]
  },
  {
    "objectID": "export.html",
    "href": "export.html",
    "title": "06_export",
    "section": "",
    "text": "01 process notes, export\n\n\nprocess_notes\n\n process_notes (notes:list[str], export:bool=False,\n                test_cml_fp:str|None=None)\n\nProcesses list of notes, converting each one into an UpdateData object and stores them in an Updates container object.\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nnotes\nlist\n\nlist[str]\n\n\nexport\nbool\nFalse\nIf True, creates export directory w/ datetime suffix and exports the following:- notes list yml- pickled Updates object- AF updates xlsx- working maint file updates xlsx- offcycle file xlsx- log trk xlsx\n\n\ntest_cml_fp\nstr | None\nNone\ndisregard, deprecated\n\n\nReturns\nUpdates\n\nss.Updates",
    "crumbs": [
      "06_export"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "srs_updates",
    "section": "",
    "text": "Docs: https://pyronone.github.io/srs_updates/",
    "crumbs": [
      "srs_updates"
    ]
  },
  {
    "objectID": "index.html#overview",
    "href": "index.html#overview",
    "title": "srs_updates",
    "section": "Overview",
    "text": "Overview\nThis package streamlines and automates the data update workflow for Sears, dramatically reducing manual effort and minimizing errors. Designed for efficiency and clarity, the package pulls data directly from our internal ticketing system, organizes it, enriches it with relevant data sources, and outputs fully formatted update files—all at the push of a button.",
    "crumbs": [
      "srs_updates"
    ]
  },
  {
    "objectID": "index.html#key-features",
    "href": "index.html#key-features",
    "title": "srs_updates",
    "section": "Key Features",
    "text": "Key Features\n\nAutomated Ticket Scraping\nThe tool scrapes relevant data update tickets from our internal ticket system, eliminating the need for manual copy-pasting or sorting.\nStructured Spreadsheet Interface\nNotes from the tickets are parsed and organized into a centralized spreadsheet using a set of predefined codes, ensuring consistency and readability.\nIntegrated Data Enrichment\nThe spreadsheet pulls in supplementary data from various sources, including reports from the plan custodian and our internal databases, to ensure comprehensive and accurate updates.\nOne-Click Update Generation\nWith a single command, the package generates all necessary files required to update both internal and external databases. This includes:\n- Data files in the correct format\n- Detailed changelogs\n- Full operation logs for traceability\nSmart Update Targeting\nThe package automatically determines whether each update applies to the internal database, the external database, or both. It also distinguishes whether the update pertains to the member or the surviving spouse, ensuring precise routing and formatting of records.",
    "crumbs": [
      "srs_updates"
    ]
  }
]